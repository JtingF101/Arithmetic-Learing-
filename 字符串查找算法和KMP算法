//一个简单的匹配算法
int Index_BF(char const *S, char const *T, int pos)
{
    if(S == NULL || T == NULL)
    {
         return -1;
    }
    if(pos < 0 || pos > strlen(S) - strlen(T))
    {
         return -1;
    }
    /*------------------------------------*/

    //若串S中从第pos(S的下标0<= pos <=StrLength(S))个字符起存在和串T相同的子串，则匹配成功。
    //返回第一个这样的子串在串S中的下标；否则返回-1
    int i = pos;
    int j = 0;
    while(S[i+j]!='\0' && T[j] != '\0')
    {
        if(S[i+j] == T[j])
        {
            j++;//继续比较后一个字符
        }
        else
        {
            //重新开始新一轮的匹配
            i++;
            j=0;
        }
    }
    if(T[j] == '\0')
    {
        return i;//匹配成功，返回下标
    }
    else
    {
        return -1;//串S中(第pos个字符起)不存在和串T相同的子串
    }
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*功能：求模式串值
 *参数：ptn：模式串
 *nextval：保存模式串值的数组
 */
void get_nextval(char const *ptn, int *nextval)
{
    int i = 0;
    nextval[0] = -1;
    int j = -1;
    int plen = strlen(ptn);

    if(ptn == NULL || nextval == NULL)
    {
        return;
    }
    while(i < plen)
    {
        if(j == -1 || ptn[i] == ptn[j])
        {
            ++i;
            ++j;
            if(ptn[i] != ptn[j])
            {
                nextval[i] = j;
            }
            else
            {
                nextval[i] = nextval[j];
            }
        }
        else
        {
            j = nextval[j];
        }
    }
}


/*功能：实现KMP算法
 *参数：src：源串
 *      patn：模式串
 *      nextval：模式串值
 *      pos：源串开始的位置
 *返回值：若匹配成功，则返回下标；若出错或匹配不成功，则返回-1
 */
int kmp_search( char const *src, char const *patn, int const *nextval,int pos)
{
    int i = pos;
    int j = 0;
    if(src == NULL || patn ==NULL)
    {
        return -1;
    }
    int slen = strlen(src);
    int plen = strlen(patn);

    if(pos < 0 || pos > slen)
    {
        return -1;
    }

    while(i < slen && j < plen)
    {
        if(j == -1 || src[i] == patn[j])
        {
            ++i;
            ++j;
        }
        else
        {
            j = nextval[j];
            //当匹配失效时，直接用p[j_next]与s[i]比较
            //下面阐述怎么求这个值，即匹配失效后的下一次匹配的位置
        }
    }
    if( j >= plen)
    {
        return i - plen;//返回下标，从0开始
    }
    else
    {
        return -1;
    }
}

int main()
{
    char src[] = "aabcabcebafabcabceabcaefabcacdabcababce";
    char prn[] = "abce";

    int *nextval = (int *)malloc(sizeof(int)* strlen(prn));
    get_nextval(prn,nextval);
    int i =0;
    for(i = 0; i < strlen(prn); i++)
    {
        printf("%d ",nextval[i]);
    }
    printf("\n");
    printf("the result is : %d\n",kmp_search(src, prn, nextval,5));
    
    return 0;
}
   /*KMP的时间复杂度为O(n + m)，空间复杂度为O(m)。
   简单字符串匹配算法的时间复杂度为O(n*m)，空间复杂度为O(1)。
   其中，n为原串的长度，m为模式串的长度。
   learn from http://blog.chinaunix.net/uid-26548237-id-3367953.html
   */
