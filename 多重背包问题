题目：

有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

 

一、基本算法
这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则有状态转移方程：

f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k<=n[i]}

复杂度是O(V*Σn[i])。

 

代码:
#include <iostream>
#include <algorithm>
#define N 1002
using namespace std;
 
int f[N];
int w[N];
int v[N];
int s[N];
 
int main() {
    int n,W; cin >> n >> W;
    for(int i=1;i<=n;i++) {
        cin >> w[i] >> v[i] >> s[i];
    }
    for(int i=1;i<=n;i++) {
        for(int j=W;j>=w[i];j--) {
            for(int k=0;k<=s[i] && k*w[i] <=j ;k++) {
                f[j] = max(f[j],f[j-k*w[i]] + k*v[i]);
            }
        }
    }
    cout << f[W] <<endl;
    return 0;
}
 


二、转化为01背包问题
另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为Σn[i]的01背包问题，直接求解，复杂度仍然是O(V*Σn[i])。

但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。

方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。

分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。

这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为 O(V*Σlog n[i]) 的01背包问题，是很大的改进。

 

下面给出上面方法处理一件多重背包中物品的伪代码：

MULTIPLEPACK(cost,weight,amount): //其中 amount 表示物品的件数。
/*处理总费用不小于背包容量的物体*/
if cost*amount >= V
    then  COMPLETEPACK(cost,weight)   //当做完全背包问题处理
        return
/*处理总费用小于背包容量的物体*/
int k=1 
while k < amount
    do         
        ZEROONEPACK( k*cost,k*weight )   //做 01 背包算法
        amount = amount - k  //用来保证分成的这几件物品的系数和为n[i]
        k = k*2  //考虑二进制的思想，把第i种物品换成若干件物品
ZEROONEPACK(amount*cost,amount*weight)
